{
    "sourceFile": "src/main/java/com/example/lastdemo/blockchain/BlockchainService.java",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1725335733030,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1725336550759,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,9 @@\n import org.springframework.stereotype.Service;\r\n \r\n import java.security.MessageDigest;\r\n import java.util.ArrayList;\r\n-import java.util.Date;  // Date 클래스를 임포트\r\n+import java.util.Date;\r\n import java.util.List;\r\n \r\n @Service\r\n public class BlockchainService {\r\n@@ -16,17 +16,17 @@\n         blockchain.add(createGenesisBlock());\r\n     }\r\n \r\n     public Block createGenesisBlock() {\r\n-        long timestamp = new Date().getTime();  \r\n+        long timestamp = new Date().getTime();\r\n         String hash = calculateHash(0, \"0\", timestamp, \"Genesis Block\");\r\n         return new Block(0, \"0\", timestamp, \"Genesis Block\", hash);\r\n     }\r\n \r\n     public Block createNewBlock(String data) {\r\n         Block previousBlock = getLatestBlock();\r\n         int newIndex = previousBlock.getIndex() + 1;\r\n-        long timestamp = new Date().getTime(); \r\n+        long timestamp = new Date().getTime();\r\n         String hash = calculateHash(newIndex, previousBlock.getHash(), timestamp, data);\r\n         Block newBlock = new Block(newIndex, previousBlock.getHash(), timestamp, data, hash);\r\n         blockchain.add(newBlock);\r\n         return newBlock;\r\n@@ -39,8 +39,24 @@\n     public List<Block> getBlockchain() {\r\n         return blockchain;\r\n     }\r\n \r\n+    public boolean isChainValid() {\r\n+        for (int i = 1; i < blockchain.size(); i++) {\r\n+            Block currentBlock = blockchain.get(i);\r\n+            Block previousBlock = blockchain.get(i - 1);\r\n+\r\n+            if (!currentBlock.getHash().equals(calculateHash(currentBlock.getIndex(), currentBlock.getPreviousHash(), currentBlock.getTimestamp(), currentBlock.getData()))) {\r\n+                return false;\r\n+            }\r\n+\r\n+            if (!currentBlock.getPreviousHash().equals(previousBlock.getHash())) {\r\n+                return false;\r\n+            }\r\n+        }\r\n+        return true;\r\n+    }\r\n+\r\n     private String calculateHash(int index, String previousHash, long timestamp, String data) {\r\n         String value = index + previousHash + timestamp + data;\r\n         try {\r\n             MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\r\n"
                },
                {
                    "date": 1725342446368,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,68 +8,77 @@\n import java.util.List;\r\n \r\n @Service\r\n public class BlockchainService {\r\n-    private List<Block> blockchain;\r\n+    private List<Block> blockchain;  // 블록체인 데이터를 저장하는 리스트\r\n \r\n     public BlockchainService() {\r\n+        // 생성자: 블록체인 초기화 및 제네시스 블록 생성\r\n         blockchain = new ArrayList<>();\r\n-        blockchain.add(createGenesisBlock());\r\n+        blockchain.add(createGenesisBlock());  // 제네시스 블록을 블록체인에 추가\r\n     }\r\n \r\n     public Block createGenesisBlock() {\r\n-        long timestamp = new Date().getTime();\r\n-        String hash = calculateHash(0, \"0\", timestamp, \"Genesis Block\");\r\n-        return new Block(0, \"0\", timestamp, \"Genesis Block\", hash);\r\n+        // 제네시스 블록 생성 메서드\r\n+        long timestamp = new Date().getTime();  // 현재 시간의 타임스탬프를 가져옴\r\n+        String hash = calculateHash(0, \"0\", timestamp, \"Genesis Block\");  // 제네시스 블록의 해시 계산\r\n+        return new Block(0, \"0\", timestamp, \"Genesis Block\", hash);  // 제네시스 블록 생성 후 반환\r\n     }\r\n \r\n     public Block createNewBlock(String data) {\r\n-        Block previousBlock = getLatestBlock();\r\n-        int newIndex = previousBlock.getIndex() + 1;\r\n-        long timestamp = new Date().getTime();\r\n-        String hash = calculateHash(newIndex, previousBlock.getHash(), timestamp, data);\r\n-        Block newBlock = new Block(newIndex, previousBlock.getHash(), timestamp, data, hash);\r\n-        blockchain.add(newBlock);\r\n-        return newBlock;\r\n+        // 새로운 블록 생성 메서드\r\n+        Block previousBlock = getLatestBlock();  // 이전 블록(가장 최신 블록) 가져오기\r\n+        int newIndex = previousBlock.getIndex() + 1;  // 새로운 블록의 인덱스는 이전 블록의 인덱스 + 1\r\n+        long timestamp = new Date().getTime();  // 현재 시간의 타임스탬프를 가져옴\r\n+        String hash = calculateHash(newIndex, previousBlock.getHash(), timestamp, data);  // 새로운 블록의 해시 계산\r\n+        Block newBlock = new Block(newIndex, previousBlock.getHash(), timestamp, data, hash);  // 새로운 블록 생성\r\n+        blockchain.add(newBlock);  // 블록체인에 새로운 블록 추가\r\n+        return newBlock;  // 생성된 새로운 블록 반환\r\n     }\r\n \r\n     public Block getLatestBlock() {\r\n-        return blockchain.get(blockchain.size() - 1);\r\n+        // 가장 최신의 블록을 반환하는 메서드\r\n+        return blockchain.get(blockchain.size() - 1);  // 리스트의 마지막 블록 반환\r\n     }\r\n \r\n     public List<Block> getBlockchain() {\r\n-        return blockchain;\r\n+        // 블록체인 전체를 반환하는 메서드\r\n+        return blockchain;  // 블록체인 리스트 반환\r\n     }\r\n \r\n     public boolean isChainValid() {\r\n+        // 블록체인의 유효성을 검사하는 메서드\r\n         for (int i = 1; i < blockchain.size(); i++) {\r\n-            Block currentBlock = blockchain.get(i);\r\n-            Block previousBlock = blockchain.get(i - 1);\r\n+            Block currentBlock = blockchain.get(i);  // 현재 블록 가져오기\r\n+            Block previousBlock = blockchain.get(i - 1);  // 이전 블록 가져오기\r\n \r\n+            // 현재 블록의 해시가 올바른지 확인\r\n             if (!currentBlock.getHash().equals(calculateHash(currentBlock.getIndex(), currentBlock.getPreviousHash(), currentBlock.getTimestamp(), currentBlock.getData()))) {\r\n-                return false;\r\n+                return false;  // 해시가 올바르지 않으면 유효하지 않음\r\n             }\r\n \r\n+            // 현재 블록의 previousHash가 이전 블록의 해시와 일치하는지 확인\r\n             if (!currentBlock.getPreviousHash().equals(previousBlock.getHash())) {\r\n-                return false;\r\n+                return false;  // 일치하지 않으면 유효하지 않음\r\n             }\r\n         }\r\n-        return true;\r\n+        return true;  // 모든 블록이 유효하면 true 반환\r\n     }\r\n \r\n     private String calculateHash(int index, String previousHash, long timestamp, String data) {\r\n-        String value = index + previousHash + timestamp + data;\r\n+        // 블록의 해시를 계산하는 메서드\r\n+        String value = index + previousHash + timestamp + data;  // 해시 계산을 위한 입력 값 생성\r\n         try {\r\n-            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\r\n-            byte[] hash = digest.digest(value.getBytes(\"UTF-8\"));\r\n-            StringBuilder hexString = new StringBuilder();\r\n+            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");  // SHA-256 해시 알고리즘 사용\r\n+            byte[] hash = digest.digest(value.getBytes(\"UTF-8\"));  // 입력 값을 해시하여 바이트 배열로 변환\r\n+            StringBuilder hexString = new StringBuilder();  // 해시 값을 16진수 문자열로 변환하기 위한 StringBuilder\r\n             for (byte b : hash) {\r\n-                String hex = Integer.toHexString(0xff & b);\r\n-                if (hex.length() == 1) hexString.append('0');\r\n-                hexString.append(hex);\r\n+                String hex = Integer.toHexString(0xff & b);  // 바이트 값을 16진수로 변환\r\n+                if (hex.length() == 1) hexString.append('0');  // 한 자릿수일 경우 앞에 '0'을 추가하여 두 자릿수로 맞춤\r\n+                hexString.append(hex);  // 16진수 문자열을 StringBuilder에 추가\r\n             }\r\n-            return hexString.toString();\r\n+            return hexString.toString();  // 최종 해시 문자열 반환\r\n         } catch (Exception e) {\r\n-            throw new RuntimeException(e);\r\n+            throw new RuntimeException(e);  // 해시 계산 중 예외 발생 시 런타임 예외 발생\r\n         }\r\n     }\r\n }\r\n"
                }
            ],
            "date": 1725335733030,
            "name": "Commit-0",
            "content": "package com.example.lastdemo.blockchain;\r\n\r\nimport org.springframework.stereotype.Service;\r\n\r\nimport java.security.MessageDigest;\r\nimport java.util.ArrayList;\r\nimport java.util.Date;  // Date 클래스를 임포트\r\nimport java.util.List;\r\n\r\n@Service\r\npublic class BlockchainService {\r\n    private List<Block> blockchain;\r\n\r\n    public BlockchainService() {\r\n        blockchain = new ArrayList<>();\r\n        blockchain.add(createGenesisBlock());\r\n    }\r\n\r\n    public Block createGenesisBlock() {\r\n        long timestamp = new Date().getTime();  \r\n        String hash = calculateHash(0, \"0\", timestamp, \"Genesis Block\");\r\n        return new Block(0, \"0\", timestamp, \"Genesis Block\", hash);\r\n    }\r\n\r\n    public Block createNewBlock(String data) {\r\n        Block previousBlock = getLatestBlock();\r\n        int newIndex = previousBlock.getIndex() + 1;\r\n        long timestamp = new Date().getTime(); \r\n        String hash = calculateHash(newIndex, previousBlock.getHash(), timestamp, data);\r\n        Block newBlock = new Block(newIndex, previousBlock.getHash(), timestamp, data, hash);\r\n        blockchain.add(newBlock);\r\n        return newBlock;\r\n    }\r\n\r\n    public Block getLatestBlock() {\r\n        return blockchain.get(blockchain.size() - 1);\r\n    }\r\n\r\n    public List<Block> getBlockchain() {\r\n        return blockchain;\r\n    }\r\n\r\n    private String calculateHash(int index, String previousHash, long timestamp, String data) {\r\n        String value = index + previousHash + timestamp + data;\r\n        try {\r\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\r\n            byte[] hash = digest.digest(value.getBytes(\"UTF-8\"));\r\n            StringBuilder hexString = new StringBuilder();\r\n            for (byte b : hash) {\r\n                String hex = Integer.toHexString(0xff & b);\r\n                if (hex.length() == 1) hexString.append('0');\r\n                hexString.append(hex);\r\n            }\r\n            return hexString.toString();\r\n        } catch (Exception e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n}\r\n"
        }
    ]
}